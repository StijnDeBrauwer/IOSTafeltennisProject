class Serie: Codable {
    var name: String
    var matches: [Match] = []
    var players: [Player] = [] // the index of each player is there ranking
    //var ranking: Ranking
    
    init(name: String){
        self.name = name
    }
    
    func matchesOfPlayer(player: Player) -> [Match] {
        let result: [Match] = matches.filter{ $0.playerA == player || $0.playerB == player}
        return result
    }
    
    func orderRanking(){
        players = players.sorted(by: {$0.rankingScore > $1.rankingScore})
    }
    
    func changeWinnerMatch(oldMatch: Match, newMatch: Match){
        if(oldMatch.getWinner() != newMatch.getWinner()) {
            
            let playerA = oldMatch.getWinner()
            let playerB = newMatch.getWinner()
            
            playerA.rankingScore-=1
            playerB.rankingScore+=1
            
            players[players.index(of: playerA)!].rankingScore = playerA.rankingScore
           players[players.index(of: playerB)!].rankingScore = playerB.rankingScore
            
            
        }
    }
    //Bij het wijzigen van een speler zal de matchen van deze speler ook veranderen
    func playerDeleteMatches(oldplayer: Player){
        matches = matches.filter({$0.playerA != oldplayer || $0.playerB != oldplayer})
    }
    
    func getRankingPlayer(selectedPlayer: Player) -> Int{
        //filter en map
        let index = players.index(where: {$0 == selectedPlayer})
        
        guard let i = index else {
            return 0
        }
        return i + 1
    }
    
    func setScorePlayer(selectedPlayer: Player, newScore: Int){
        
        let index = getRankingPlayer(selectedPlayer: selectedPlayer) - 1
        players[index] = selectedPlayer
    }
    
    func playerAlreadyExists(firstname: String, lastname: String) -> Bool{
       return players.filter({$0.firstname == firstname && $0.lastname == lastname}).count > 0 ?  true : false
    }
    
    private enum CodingKeys: CodingKey {
        case name
        case matches
        case players
        case ranking
    }
    
    
    
    /*
     This method is required by the Encodable protocol (Codable is actually Encodable & Decodable).
     It is normally generated by the compiler but can be implemented to do custom encoding.
     */
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(name, forKey: .name)
        try container.encode(players, forKey: .players)
        try container.encode(matches, forKey: .matches)
    }
    
    /*
     This initializer is required by the Decodable protocol.
     It is normally generated by the compiler but can be implemented to do custom decoding.
     */
    required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let name = try container.decode(String.self, forKey: .name)
        let matches = try container.decode([Match].self, forKey: .matches)
        let players = try container.decode([Player].self, forKey: .players)
        self.name = name
        self.matches = matches
        self.players = players
    }
}
