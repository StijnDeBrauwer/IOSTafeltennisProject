class Serie: Codable {
    var name: String
    var matches: [Match] = []
    var players: [Player] = [] // the index of each player is there ranking
    //var ranking: Ranking
    
    init(name: String){
        self.name = name
    }
    
    func matchesOfPlayer(player: Player) -> [Match] {
        let result: [Match] = matches.filter{ $0.playerA == player || $0.playerB == player}
        return result
    }
    
    func orderRanking(){
        players = players.sorted(by: {$0.rankingScore > $1.rankingScore})
    }
    
    func changeWinnerMatch(oldMatch: Match, newMatch: Match){
        if(oldMatch.getWinner() != newMatch.getWinner()) {
            
            let newMatchWinner = newMatch.getWinner()
            var matchLoser: Player
            if(newMatch.playerA == newMatchWinner){
                matchLoser = newMatch.playerB
            } else {
               matchLoser = newMatch.playerB
            }
            players[players.index(of: newMatchWinner)!].rankingScore+=1
            players[players.index(of: matchLoser)!].rankingScore-=1
            
        }
    }
    //Bij het wijzigen van een speler zal de matchen van deze speler ook veranderen
    func changeMatchesWithNewPlayer(oldplayer: Player, newplayer: Player){
    matches.forEach {
            if($0.playerA == oldplayer){
                $0.playerA = newplayer
            }else if ($0.playerB == oldplayer){
                $0.playerB = newplayer
            }
            
        }
    }
    
    // set ranking score back of winner in case the match was deleted
    func setRankingScoreBack(deletedPlayer: Player) {
        let oldmatches = matches.filter({$0.playerA == deletedPlayer || $0.playerB == deletedPlayer})
        
        oldmatches.forEach({if($0.getWinner() != deletedPlayer){
            let otherPlayer = $0.playerA == deletedPlayer ? $0.playerB : $0.playerA
            let index = players.index(of: otherPlayer)
            if(players[index!].rankingScore > 0){
                players[index!].rankingScore-=1
                }
            }
            
        })
    }
    
    //get the ranking of a player to display (starts from 1)
    func getRankingPlayer(selectedPlayer: Player) -> Int{
        //filter en map
        let index = players.index(where: {$0 == selectedPlayer})
        
        guard let i = index else {
            return 0
        }
        return i + 1
    }
    
    func setScorePlayer(selectedPlayer: Player, newScore: Int){
        
        let index = getRankingPlayer(selectedPlayer: selectedPlayer) - 1
        players[index] = selectedPlayer
    }
    
    func playerAlreadyExists(firstname: String, lastname: String) -> Bool{
       return players.filter({$0.firstname == firstname && $0.lastname == lastname}).count > 0 ?  true : false
    }
    
    private enum CodingKeys: CodingKey {
        case name
        case matches
        case players
        case ranking
    }
    
    
    
    /*
     This method is required by the Encodable protocol (Codable is actually Encodable & Decodable).
     It is normally generated by the compiler but can be implemented to do custom encoding.
     */
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(name, forKey: .name)
        try container.encode(players, forKey: .players)
        try container.encode(matches, forKey: .matches)
    }
    
    /*
     This initializer is required by the Decodable protocol.
     It is normally generated by the compiler but can be implemented to do custom decoding.
     */
    required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let name = try container.decode(String.self, forKey: .name)
        let matches = try container.decode([Match].self, forKey: .matches)
        let players = try container.decode([Player].self, forKey: .players)
        self.name = name
        self.matches = matches
        self.players = players
    }
}
